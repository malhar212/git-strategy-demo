# TEMPLATE: Per-PR Sandbox Deployment
# This workflow deploys a sandbox environment for each PR to staging
# Requires: Kubernetes cluster with namespace provisioning capability
#
# To use this template:
# 1. Set up your K8s cluster and configure KUBECONFIG secret
# 2. Customize the deploy steps for your application
# 3. Update the ingress/URL pattern for your domain

name: Deploy PR Sandbox

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [staging]

# Uncomment to enable:
# env:
#   KUBECONFIG: ${{ secrets.KUBECONFIG }}
#   REGISTRY: ghcr.io/${{ github.repository }}

jobs:
  deploy-sandbox:
    runs-on: ubuntu-latest
    # Uncomment to enable:
    # if: github.event.pull_request.draft == false
    steps:
      - name: Template Notice
        run: |
          echo "=================================================="
          echo "TEMPLATE: This workflow is a template and disabled by default"
          echo "To enable sandbox deployments:"
          echo "1. Configure KUBECONFIG secret"
          echo "2. Uncomment the relevant sections"
          echo "3. Customize for your infrastructure"
          echo "=================================================="

      # Uncomment below to enable sandbox deployment:
      #
      # - name: Checkout
      #   uses: actions/checkout@v4
      #
      # - name: Set up Docker Buildx
      #   uses: docker/setup-buildx-action@v3
      #
      # - name: Login to Container Registry
      #   uses: docker/login-action@v3
      #   with:
      #     registry: ghcr.io
      #     username: ${{ github.actor }}
      #     password: ${{ secrets.GITHUB_TOKEN }}
      #
      # - name: Generate sandbox name
      #   id: sandbox
      #   run: |
      #     PR_NUMBER=${{ github.event.pull_request.number }}
      #     SANDBOX_NAME="pr-${PR_NUMBER}"
      #     echo "name=${SANDBOX_NAME}" >> $GITHUB_OUTPUT
      #     echo "namespace=sandbox-${SANDBOX_NAME}" >> $GITHUB_OUTPUT
      #     echo "url=https://${SANDBOX_NAME}.sandbox.example.com" >> $GITHUB_OUTPUT
      #
      # - name: Build and push image
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: .
      #     push: true
      #     tags: ${{ env.REGISTRY }}:${{ steps.sandbox.outputs.name }}
      #     cache-from: type=gha
      #     cache-to: type=gha,mode=max
      #
      # - name: Create namespace
      #   run: |
      #     kubectl create namespace ${{ steps.sandbox.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
      #
      # - name: Deploy to sandbox
      #   run: |
      #     # Example: Using Helm
      #     # helm upgrade --install ${{ steps.sandbox.outputs.name }} ./charts/app \
      #     #   --namespace ${{ steps.sandbox.outputs.namespace }} \
      #     #   --set image.tag=${{ steps.sandbox.outputs.name }} \
      #     #   --set ingress.host=${{ steps.sandbox.outputs.name }}.sandbox.example.com
      #
      #     echo "Deployed sandbox: ${{ steps.sandbox.outputs.url }}"
      #
      # - name: Comment PR with sandbox URL
      #   uses: actions/github-script@v7
      #   with:
      #     script: |
      #       const sandboxUrl = '${{ steps.sandbox.outputs.url }}';
      #
      #       // Find existing comment
      #       const { data: comments } = await github.rest.issues.listComments({
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         issue_number: context.payload.pull_request.number
      #       });
      #
      #       const botComment = comments.find(c =>
      #         c.user.type === 'Bot' && c.body.includes('Sandbox Environment')
      #       );
      #
      #       const body = `## ðŸš€ Sandbox Environment
      #
      #       Your PR sandbox is ready!
      #
      #       **URL:** ${sandboxUrl}
      #
      #       This environment will be automatically cleaned up when the PR is closed.
      #
      #       ---
      #       *Last deployed: ${new Date().toISOString()}*`;
      #
      #       if (botComment) {
      #         await github.rest.issues.updateComment({
      #           owner: context.repo.owner,
      #           repo: context.repo.repo,
      #           comment_id: botComment.id,
      #           body
      #         });
      #       } else {
      #         await github.rest.issues.createComment({
      #           owner: context.repo.owner,
      #           repo: context.repo.repo,
      #           issue_number: context.payload.pull_request.number,
      #           body
      #         });
      #       }
